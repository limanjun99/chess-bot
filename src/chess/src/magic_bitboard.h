#pragma once

#include <array>
#include <vector>

#include "bitboard.h"

using namespace chess;

// Fast lookup of sliding piece attacks.
// Shift, masks and magics should be generated by tools/magic_calculator.cpp
// Details here: https://www.chessprogramming.org/Magic_Bitboards
class MagicBitboard {
public:
  // Note that `masks_` is an array of `uint64_t` instead of `Bitboard`, to maintain compatibility
  // with the tool (magic_calculator.cpp) that calculates it.
  constexpr MagicBitboard(std::array<std::pair<int, int>, 4> directions, std::array<int, 64> shifts,
                          std::array<uint64_t, 64> masks_, std::array<uint64_t, 64> magics);

  // Returns a bitboard of squares attacked by the given bit.
  constexpr Bitboard attacks(Bitboard bit, Bitboard occupancy) const;

private:
  std::array<std::pair<int, int>, 4> directions;  // How the piece moves ({delta y, delta x}).
  std::array<int, 64> shifts;
  std::array<Bitboard, 64> masks;
  std::array<uint64_t, 64> magics;
  std::vector<Bitboard> moves[64];

  // Precompute the moves bitboard for each square.
  constexpr void precompute();
};

constexpr MagicBitboard::MagicBitboard(std::array<std::pair<int, int>, 4> directions, std::array<int, 64> shifts,
                                       std::array<uint64_t, 64> masks_, std::array<uint64_t, 64> magics)
    : directions{directions}, shifts{shifts}, magics{magics} {
  std::transform(masks_.begin(), masks_.end(), masks.begin(), [](uint64_t mask) { return Bitboard{mask}; });
  for (int i = 0; i < 64; i++) moves[i].resize(1 << (64 - shifts[i]));
  precompute();
}

constexpr Bitboard MagicBitboard::attacks(Bitboard bit, Bitboard occupancy) const {
  int index{bit.to_index()};
  uint64_t hash = (static_cast<uint64_t>(occupancy & masks[index]) * magics[index]) >> shifts[index];
  return moves[index][hash];
};

constexpr void MagicBitboard::precompute() {
  for (int index = 0; index < 64; index++) {
    int y = index / 8;
    int x = index % 8;
    for (const Bitboard occupancy : masks[index].iterate_subsets()) {
      Bitboard move_bitmap{0};
      for (auto [delta_y, delta_x] : directions) {
        int to_y = y + delta_y;
        int to_x = x + delta_x;
        while (0 <= to_y && to_y < 8 && 0 <= to_x && to_x < 8) {
          Bitboard to_bit{Bitboard::from_coordinate(to_y, to_x)};
          move_bitmap ^= to_bit;
          if (to_bit & occupancy) break;
          to_y += delta_y;
          to_x += delta_x;
        }
      }
      uint64_t hash = (static_cast<uint64_t>(occupancy) * magics[index]) >> shifts[index];
      moves[index][hash] = move_bitmap;
    }
  }
}